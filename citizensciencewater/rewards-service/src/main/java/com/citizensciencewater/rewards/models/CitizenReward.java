package com.citizensciencewater.rewards.models;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * JPA Entity representing a citizen's reward status.
 * Tracks points earned and achievement badges for a citizen's contributions.
 * Data is persisted to MySQL database.
 * 
 * @author KF7014 Assessment
 * @version 2.0 - JPA Implementation
 */
@Entity
@Table(name = "citizen_rewards", 
       indexes = {
           @Index(name = "idx_citizen_id", columnList = "citizen_id", unique = true),
           @Index(name = "idx_total_points", columnList = "total_points"),
           @Index(name = "idx_current_badge", columnList = "current_badge")
       })
@EntityListeners(AuditingEntityListener.class)
public class CitizenReward {

    /**
     * Primary key - auto-generated by database
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Unique identifier for the citizen (business key)
     */
    @Column(name = "citizen_id", nullable = false, unique = true, length = 100)
    private String citizenId;

    /**
     * Total points earned by the citizen
     */
    @Column(name = "total_points", nullable = false)
    private int totalPoints;

    /**
     * Number of valid observations submitted
     */
    @Column(name = "valid_observations", nullable = false)
    private int validObservations;

    /**
     * Number of complete observations submitted
     */
    @Column(name = "complete_observations", nullable = false)
    private int completeObservations;

    /**
     * List of achievement badges earned (stored as comma-separated values)
     * e.g., "Bronze,Silver,Gold"
     */
    @Column(name = "badges", length = 500)
    private String badges;

    /**
     * Current badge level of the citizen
     */
    @Column(name = "current_badge", nullable = false, length = 50)
    private String currentBadge;

    /**
     * Timestamp when this record was created
     */
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /**
     * Timestamp when this record was last updated
     */
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // =====================
    // Constructors
    // =====================

    /**
     * Default constructor (required by JPA)
     */
    public CitizenReward() {
        this.totalPoints = 0;
        this.validObservations = 0;
        this.completeObservations = 0;
        this.badges = "";
        this.currentBadge = "None";
    }

    /**
     * Constructor with citizen ID
     */
    public CitizenReward(String citizenId) {
        this();
        this.citizenId = citizenId;
    }

    /**
     * Constructor with all fields (for testing/initialization)
     */
    public CitizenReward(String citizenId, int totalPoints, int validObservations,
                         int completeObservations, List<String> badgeList, String currentBadge) {
        this.citizenId = citizenId;
        this.totalPoints = totalPoints;
        this.validObservations = validObservations;
        this.completeObservations = completeObservations;
        this.setBadgesList(badgeList);
        this.currentBadge = currentBadge != null ? currentBadge : "None";
    }

    // =====================
    // Business Logic Methods
    // =====================

    /**
     * Add points for a valid observation.
     * Awards:
     * - 10 points for valid observation
     * - +10 bonus points if observation is complete
     */
    public void addObservation(boolean isComplete) {
        this.validObservations++;
        this.totalPoints += 10; // Base points for valid observation

        if (isComplete) {
            this.completeObservations++;
            this.totalPoints += 10; // Bonus points for complete observation
        }

        updateBadges();
    }

    /**
     * Update badge level based on total points.
     * Bronze: 100 points
     * Silver: 200 points
     * Gold: 500 points
     */
    private void updateBadges() {
        List<String> badgeList = getBadgesList();
        
        if (totalPoints >= 500 && !badgeList.contains("Gold")) {
            badgeList.add("Gold");
            currentBadge = "Gold";
            setBadgesList(badgeList);
        } else if (totalPoints >= 200 && !badgeList.contains("Silver")) {
            badgeList.add("Silver");
            currentBadge = "Silver";
            setBadgesList(badgeList);
        } else if (totalPoints >= 100 && !badgeList.contains("Bronze")) {
            badgeList.add("Bronze");
            currentBadge = "Bronze";
            setBadgesList(badgeList);
        }
    }

    /**
     * Calculate points needed for next badge.
     * @return points needed for next badge, or 0 if at maximum level.
     */
    public int getPointsToNextBadge() {
        if (totalPoints < 100) return 100 - totalPoints;
        else if (totalPoints < 200) return 200 - totalPoints;
        else if (totalPoints < 500) return 500 - totalPoints;
        return 0; // Already at Gold level
    }

    /**
     * Get the name of the next badge to achieve.
     * @return name of next badge, or "Maximum Level" if at Gold.
     */
    public String getNextBadge() {
        if (totalPoints < 100) return "Bronze";
        else if (totalPoints < 200) return "Silver";
        else if (totalPoints < 500) return "Gold";
        return "Maximum Level";
    }

    // =====================
    // Helper Methods for Badge List Conversion
    // =====================

    /**
     * Convert comma-separated badges string to List
     * @return List of badge names
     */
    public List<String> getBadgesList() {
        List<String> badgeList = new ArrayList<>();
        if (badges != null && !badges.trim().isEmpty()) {
            String[] badgeArray = badges.split(",");
            for (String badge : badgeArray) {
                if (!badge.trim().isEmpty()) {
                    badgeList.add(badge.trim());
                }
            }
        }
        return badgeList;
    }

    /**
     * Convert List of badges to comma-separated string
     * @param badgeList List of badge names
     */
    public void setBadgesList(List<String> badgeList) {
        if (badgeList == null || badgeList.isEmpty()) {
            this.badges = "";
        } else {
            this.badges = String.join(",", badgeList);
        }
    }

    // =====================
    // Getters and Setters
    // =====================

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCitizenId() {
        return citizenId;
    }

    public void setCitizenId(String citizenId) {
        this.citizenId = citizenId;
    }

    public int getTotalPoints() {
        return totalPoints;
    }

    public void setTotalPoints(int totalPoints) {
        this.totalPoints = totalPoints;
    }

    public int getValidObservations() {
        return validObservations;
    }

    public void setValidObservations(int validObservations) {
        this.validObservations = validObservations;
    }

    public int getCompleteObservations() {
        return completeObservations;
    }

    public void setCompleteObservations(int completeObservations) {
        this.completeObservations = completeObservations;
    }

    /**
     * Get badges as comma-separated string (for JPA)
     */
    public String getBadges() {
        return badges;
    }

    /**
     * Set badges as comma-separated string (for JPA)
     */
    public void setBadges(String badges) {
        this.badges = badges;
    }

    public String getCurrentBadge() {
        return currentBadge;
    }

    public void setCurrentBadge(String currentBadge) {
        this.currentBadge = currentBadge;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    // =====================
    // equals, hashCode, toString
    // =====================

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CitizenReward that = (CitizenReward) o;
        return Objects.equals(id, that.id) && 
               Objects.equals(citizenId, that.citizenId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, citizenId);
    }

    @Override
    public String toString() {
        return "CitizenReward{" +
                "id=" + id +
                ", citizenId='" + citizenId + '\'' +
                ", totalPoints=" + totalPoints +
                ", validObservations=" + validObservations +
                ", completeObservations=" + completeObservations +
                ", badges='" + badges + '\'' +
                ", currentBadge='" + currentBadge + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
}